                         hacking the Linux Kernel
       
CONVENTIONS
   Absolute path for files are usually used
   If path from root is not given, take it to have /usr/src as the home
                  directory.
   LKI : Linux Kernel Internels  
-----------------------------------------------------------------------------
OVERVIEW

Directory of linux source code : /usr/src
All header files are in : /usr/src/linux/include
    both assembly & C routines are included in this directory
The first  routine to start is /usr/src/linux/init/main.c
All version-related info is generated by /usr/src/linux/init/version.c
task_struct which is declared in linux/include/linux/sched.h holds all the
    important information.
task[0] is called "swapper" in the traditional Unices but it has othing to do 
with swapping n Linux-it is the *idle* task in Linux.    
------------------------------------------------------------------------------

Booting The System
------------------
System starts from /boot and /usr/src/linux/arch/boot/....
The best place to look for doc on this is an article by Rubini called
kerneltour.txt.I will add some of the revelant features which are comprehensive 
to me.
	The PC-BIOS performs some tests and places the IVT at physical address
0.After that it loads the first sector of the bootable device to 0x7C00, and jmups to it.
	The very first part of the Linux Kernel is written in boot/bootsect.S. 
When run it moves itself to absolute address 0x90000, loads the next 2Kb of code
from boot device to 0x90200, and rest of the kernel to 0x10000.Control from here
goes to boot/setup.S (real-mode assembly source).
	The setup portion identifies some features of the host system and the ty
pe of the vga board.It then moves the whole system from 0x10000 to 0x1000, enter
s the protected mode and jumps to the rest of the system.(0x1000).
	The next step kernel decompression,the code for which comes from 
compressed/head.S which initializes registers and invokes decompress_kernel().
Which in turn uses compressed/misc.c and xtract.c.The decompressed data goes to
1Mb location(0x100000).
	 Decompressed code is executed at address 0x1010000 
   , where all the 32-bit setup is accomplished: IDT, GDT and
   LDT are loaded, the processor and coprocessor are identified, and
   paging is setup; eventually, the routine start_kernel is invoked. The
   source for the above operations is in boot/head.S. It is probably the
   trickiest code in the whole kernel.

c code starts from init/main.c
This file and most others extensively use pointer to functions  especially
as a member of important structs.
NULL is defined in  linux/include/linux/posix_types.h to be of the
      type void *

I)          FROM main.c..........
      
   Another important thing to remember before doing anything else is that     
many variables are read from /boot/config.This is used in most of the
functions...
     1. check for the gcc version is done here and an error message is
           flagged in case of a problem
     2. various variables to define the nature of ramdisk is included.
     3. command line arguments are bound by two variables viz
                      i)MAX_INIT_ARGS
		     ii)MAX_INIT_ENVS
     4. other two variables declared here are 
                      i)memory_start and 
                     ii)memory_end    which are both unsigned longs(32bit)
     5. the first function found is char *get_options(char *, char *)
     6. another important function is static int checksetup(char *line)
		It refers of an array of structs bootsetup[] 
        whose struct has one char * and a pointer to a function -which
        takes char * and int * as its  args as its  members.                      
        This data struct(array 0f structs) is also initialized
            main.c = ending the array with {0,0}.
        This func checksetup(char *) moves through each of the
        structs of the array bootsetups[] and uses its second member
        ie func * to check & initialize the devices by using
        get_options.
      7.next important function is caliberate_delay().
        	This function shows the message"Caliberating delay loop...."
        This does things about BogoMips(a Linus invection).Another 
        global variable is also declared which is used in many device
        drivers  and other kernel sources :it is  unsigned long
        loops_per_sec.
 
/*  I didnt get the algo  */
 
     8. function static void parse_root_dev(char *line) :
            Uses a struct of static type with const char *name and const
        int num as its members.This function holds an array of such
        structs with name as the name of the device and hex number in
        num.Next loop goes through each member of the array of
        structs and compares the char * member of it with the
        char * given to the func as its argument.Using this info it
        computes a value called ROOT_DEV (defined where ?) which says
            ROOT_DEV = to_kdev_t(base+simple_strtoul(line,NULL,base?10:16));

 /*   WHAT does this to_kdev_t do>??????  */
SUP:(Prolly MKDEV is the solution search for it)
     
      9.   static void parse_options(char *line)    :  This is the comment
 * This is a simple kernel command line parsing function: itparses
 * the command line, and fills in the arguments/environment to init
 * as appropriate. Any cmd-line option is taken to be an environment
 * variable if it contains the character '='. 
           whatever it parses is stored in  char *argv_init[] and 
           char   *env_init[]. 
 
     10.If multiprocessor support is not mentioned while compiling,it
 cpu_idle() function is carried out which does nothing-just go
 into infinite loop.
     11.Then comes........asmlinkage void start_kernel(void)
 	It is like main() in a usual c program.After initializing and
 checking the system,calls         
		printk(linux_banner);
    where linux_banner is an extern char *.Then cpu_idle() is called.


II) Now the most important /usr/src/linux/kernel/sched.c..........
       This function uses many data strucures declared in
include/linux/kernel.h .It defines 7 kernel levels as follows:
#define KERN_EMERG      "<0>"   /* system is unusable */
#define KERN_ALERT      "<1>"   /* action must be taken immediately     */
#define KERN_CRIT       "<2>"   /* critical conditions                  */
#define KERN_ERR        "<3>"   /* error conditions                     */
#define KERN_WARNING    "<4>"   /* warning conditions                   */
#define KERN_NOTICE     "<5>"   /* normal but significant condition     */
#define KERN_INFO       "<6>"   /* informational                        */
#define KERN_DEBUG      "<7>"   /* debug-level messages                 */
     
             And the follwing variables are also declared in sched.c
long tick = (1000000 + HZ/2) / HZ;      /* timer interrupt  period */

[Add about the DECLARE_TASK_QUEUE()]		---> Sup
   
  An important member of task_struct is long counter : which stores the
dynamic priority of any task."It holds time in ticks for which process can
still run  before scheduling is done.Scheduler selects the process with
highest counter value" says LKI.
/* That means the process which came first into the queue,is given priority.*/

   long priority holds static priority whose maximum is 35 as hardcoded in
sys_nice().
    Scheduler checks for all the processes in the process table and takes
the process with greatest 'counter' value.If there is no process with
non-zero priority  init_task is selected and then switch_to_next() is
called from this routine.

  So much from the "scheduler proper" (as Linus Torvalds puts it).
  
If the running process is having counter== 0 ie it is no more to be run,
calculate priority for all the processes.This new dynamic priority
is equal to  static priority  plus double the present static priority.

/*...............But why is the static priority  set to such a value????
 */
    Another thing to remember:TASK_RUNNING shows that the task is in the
run queue not that it is the current task.current task is a new data
struct all together.

The add_to_runqueue(struct task_struct *) :- Inline function to add a process
	to runqueue.The whole thing is a linked list.
The del_from_runqueue(struct task_struct *) and move_last_runqueue(struct task_struct *) operate on the same lines.
 
sched.c has another function in it which void do_timer(struct pt_regs *).No ideawhat it actually does now...........

wake_up_process(struct task_struct *) what it does is saves flags (which ones no idea) , disable interrupts and then add-to-runqueue,if it not the next_run and the state is set TASK_RUNNING.Then restore_flags().

process_timeout(unsigned long) is for setting timeout=0 and waking it up.
[Add the relevant details]      -->		Sup.

int goodness(struct task_struct *,struct task_struct *,int *) is for increasing priority of a Real time process p->policy != SCHED_OTHER says this. The func. also increases the time-slice by 1 unit.

So much from the "scheduler proper" (as Linus Torvalds puts it).The scheduler()
is the core function here.

Other system calls defined  HERE:
   
          getpid()   int sys_getpid(void)   
          getppid()  int sys_getppid(void)
          getuid()   int sys_getuid(void)
          geteuid()  int sys_geteuid(void)
          getgid()   int sys_getgid(void)
               ........and  all these  use very simple algorithms (They
just take the values from task_struct and return it.)
          signal(long signal,long addr,long restorer)  
                     sets a new signal handler for signal(number)                  
   (0.01) pause()     int sys_pause(void)
                   puts the state of current task to be TASK_INTERRUPTIBLE
and calls schedule() returning 0.          

   (0.01) nice(int increment)  int sys_nice(int)
                   if difference between current->priority and increment
is not less than zero this difference is assigned to current->priority and
0 is returned.            

void wake_up(struct task_struct * *p)
void sleep_on(struct task_struct * *p)
void interruptible_sleep_on(struct task_struct * *p)
              
	are the other functions here and i am yet to hack these.


III)  From kernel/fork.c 

NOTE: All of 0.01 except  when mentioned so 
 
        Linus Torvalds in his comment of 0.01:
    "   *  'fork.c' contains the help-routines for the 'fork' system call
        * (see also system_call.s), and some misc functions ('verify_area').
        * Fork is rather simple, once you get the hang of it, but the memory
        * management can be a bitch. See 'mm/mm.c': 'copy_page_tables()' "
      There is no sys_fork() in the whole of fork.c......

in 2.0.30::The first function is static inline int find_empty_process(void)
           It checks if the number of processes active exceeds a maximum secure
level.if it exceeds,it returns with -EAGAIN.This section  which  checks 
no of processes  uses  a global variable int nr_tasks(defined in 
include/sched.h and initialized to 1 in kernel/fork.c).
           Next it checks for the number of processes in under the particular
uid(This is not made if current->uid ==0 ).error if it exceeds 
current->rlim[RLIMIT_NPROC].rlim_cur.
     RLIMIT_NPROC  : include/asm/resources.h  : defined as 6 and => max no of 
     processes. 
/*  What does this(rlim_cur)mean????????? 
*/ 
     Then the index i is returned for which task[i] is NULL (check till 
    i < NR_TASK) and if it fails, -EAGAIN is returned again.    
verify_area(void *,int) is a function in fork.c in 0.01 but it is somewhere
      in linux/mm/  in newer versions so it will be included in memory
      management section of vhlk.          
The main function here is
     in 0.01 :  int copy_process(  )   
                             17  ^^^ long variables
       first, get_free_page() is called and the returned value is type
                casted to be of (struct task_struct *)
       and it returns with -EAGAIN if the above variable is NULL.
       then *p = *current : child inherits all the father's  fields.Linus 
       says this doesnt copy supervisor stack.

/*  I do not know what a supervisor stack is
 */
       Next few lines are quite straight forward  which initializes some
members of the child's task_struct.ie child has these fields independent
of the father like p->father which is set to current->pid (this is in the  
0.01 but in the newer versions, father is not a member of task_struct)
  stime,utime,signal,alarm are all set to 0 and new pid is given which is
____________ and state is made TASK_RUNNING.
     this functon returns the pid of the new child process.This is set as
the variable long last_pid 
/* I do not know what is the pid of the child process and how last_pid is  
 *  calculated.
 */ 
and 'counter'of the child is set to the priority of the child 
/*  ( who sets it? )
 */
===============================================================================
****************************Memory Management*********************************
===============================================================================
  Now About the Memory Management and related works in Linux Kernel....
   
     TSS   Task State Segments        1 TSS associated with each task 
     LDT   Local Descriptor Tables    1 LDT per task
     GDT   Global Descriptor Tables   
        All system segments are task-specific.
        All user segments have 0x00 as its base.

The member in task_struct defining LDT is:::==========
      struct desc_struct *ldt; desc_struct defined in 
      linux/include/linux/head.h  desc_srtuct has 2 members-both unsigned long
      these numbers denote code-segment and data-stack segment of the process.
 Kernal data segment and code segment are previleged and so defined in the GDT.
       
     Different documents say that kernel do not keep page table for itself.
So uses physical memory and does not have to worry about virtual memory

/*  How do you explain this????????????????????????????  
 */                 

Virtual Memory handling in Linux::: 
          Memory id divided into pages and each page has a unique number which
is called PFN(Page Frame Number).On getting a virtual add, its virtual PFN is 
calculated (dividing by the size of page frame)and  then CPU searches processs
page tables for entry matching virtual PFN which gives physical PFN and 
multiplies it by the page size to get base addr of that page in physical memory
  ===> pages of virtual memory need not be in any particular order in physical
       memory.
          If the virtual add that is to be accessed doesnot  figure out in the 
page table entry it means that that page is not in the physical memory.So,CPU 
gives up to OS notifying OS of a page fault and process wait till the page is 
brought to main memory. This is called demand paging.
          Linux uses page aging techinque for swappimg-more it is accessed
older it is and is made to swap.
          Process table or the task_struct for processes have many important 
members for memory management related works.It includes variables for 
page-fault-counting.swappable which can be 0 or 1(can swap or not-swappable)
 and for memory management info struct mm_struct *mm.struct tss for threads.
 unsigned long saved_kernel_stack; for V86 
 unsigned long kernel_stack_page;  a pointer to page allocated in fork().
         in 0.01 kernel page size is defined to be 4096B(4KB).        


 I)from linux/mm/kmalloc.c....

        An important file here is kmalloc.c which has a man page in section 9 
of the man pages.Every malloc-header is stored in a structure called 
struct block_header - block is free or not. 

page_descriptor at the front of every page that malloc has in use.
           has pointer to the first free block in the page.and keeps a linked 
           list of page_descriptors.
       
size_descriptor describes a specific class of malloc sizes.

block_header finds its place at the front of every malloc block.      

sizes[] is an array of size_descriptor's - in the increasing order of 
block-size.
    static struct size_descriptor sizes[]
 |-----|       -------------------  struct page_descriptor *firstfree;
 |     |<<<>>> |                 |+++++++++++|------|
 |-----|       |-----------------|           |      |\
 |     |       |		 |           |------| \  
 |     |       |                 |           |      |  \  
 |     |       |                 |           |      |   \
 |     |       |                 |           |      |   / 
 |     |       |                 |           |------|  / 
 |     |       |                 |           |      |/struct block_header   
 |     |       |                 |           |------|    *firstfree;
static const   |                 |           |      |
unsigned int   |                 |           |      |
 blocksize[]   |                 |
                                           a page divided into 
                                     sizes[i]->nblocks  of blocksize[i].
                                        
The above setup makes memory mangement quite easy.
This uses Buddy system of free memory management.
                (Read Tanenbaum for details)

 there is a page header at the front  of  every page malloc has in use.
          struct page_descriptor which also makes  a linked list and keeps 
track of free blocks (struct block_header *firstfree;) and int nfree .
Block sizes and page sizes are also defined in the same file(kmalloc.c)
size_descriptor keeps track of  nmallocs,npages,nblocks,nbytesmalloced and 
nfree(all int) and struct page_descriptor *firstfree,
                   struct page_descriptor *dmafree. 
 kmalloc_init(long,long) which is called in linux/init/main.c is also defined
here  in this file as long kmalloc_init(long start_mem, long end_mem):it uses
values initialised in struct size_descriptor sizes[]  and 
                      static const unsigned int blocksize[] (giving block size)
this routine rather very simple-if you remember that 
sizeof(struct blockheader) is 32bytes.
        man 9 kmalloc says
     "kmalloc()
              allocates  size bytes, and returns a pointer to the
              allocated memory.  On  i386  the  following  bucket
              sizes  are  possible:  24, 56, 120, 244, 500, 1012,
              2032, 4072, 8168, 16360, 32744,  65512  and  131048
              bytes.  ( See linux/mm/kmalloc.c ) If an other size
              is kmalloc'ed  the the next  bigger  one  is  allo-
              cated. For priority see __get_free_pages."

 void *kmalloc(size_t size, int priority)  :::: main function
            First  loop here finds the size of first free block available that 
    can be allocated.blocksize[] and sizes[] are both defined in the ascending 
    order of size in bytes of a block.This block allocated should also house
    struct block_header-that is  taken care of,first by 
               unsigned int realsize = size + sizeof(struct block_header);
    The block is found in the following manner:-
             it checks for each blocksize incrementing index(int order) each 
             time appropriately.It goes to find the block whose size is either
             just greater than or equal to the size required.   
    (This loop is a very good piece of code-look at max limit said in 0s terms
    exploiting binary represntation methods). 

           next a check is made(checks priority with GFP_DMA) for dma and 
     pg = &bucket->dmafree;after one more check of  GFP_ATOMIC and then 
     save_flags(flags), cli() is called to block interrupts.
           another check is done to make sure the block is actually free by 
     checking corresponding block_header->bh_flags.When it succeeds all the 
     checks,different members of the page headers and block headers are 
     updated to reflect the allocation.In this case it returns a pointer 
     to a byte past block_header of the block that is allocated-done using 
     an inelligent pointer arithmetic adding 1 to the pointer hence moving
     1 sizeof(pointer) or 8 bytes.
       Other differnt error conditions are taken careof in next few labels.

void kfree(void *__ptr) ::: next main function
      
/* DIDnot read this completely ...read it lateron
 */

II)from linux/arch/i386/mm/init.c .........
        This is responsible for memory initialization routine 
    void mem_init(unsigned long start_mem, unsigned long end_mem)
and paging initialization routine
    unsigned long paging_init(unsigned long start_mem, unsigned long end_mem)
 

III)from linux/mm/page_alloc.c ....

       This and many other functions require a macro named MAP_NR which is
defined in linux/include/asm/page.h as MAP_NR(addr) to be 
(((unsigned long)(addr)) >> PAGE_SHIFT) ie divide by 4096 to get the page 
number.
  
 
Paging
------
     Linux asumes three levels of page tables.Translation from virtual to 
physical is done as in usual page tables ,except that the translation is done 
three times here and last field becomes the offset into physical memory.
The Linux Kernel says
 " Each platform that Linux runs on must provide translation macros that
   allow the kernel to traverse the page tables for a particular process.
   This way, the kernel does not need to know the format of a the entries
   or how they are arranged."
                  
 Physical pages in the system are described by the mem_map  data
  structure which is a list of mem_map_t<defined in linux/include/linux/mm.h>
  extern mem_map_t * mem_map; <- is also seen in the same file ^^^^^^^^
vm_area_struct and vm_operations_struct are also defined in the above.
         extern mem_map_t * mem_map;
   Main memory related or paging/segmentation related work is done by the
linux/mm/memory.c mainly.Page faults and other such error conditons are 
handled by  linux/include/asm/pgtable.h
   This file is worth a lot of attention and study:->
            The Linux memory management unit supports  a three level paging as 
mentioned before but intel386 supports only two levels of page tables.This is 
done by what is called "folding of one level of address translation".This 
wrapping is done by pgtable.h (in quite an intelligent way,i would say!).
Comment in this file says
  "* The Linux memory management assumes a three-level page table setup. On
   * the i386, we use that, but "fold" the mid level into the top-level page
   * table, so that we physically have the same two-level page table as the
   * i386 mmu expects."
                Some functions are defined for flushing TLBs(Translational 
Look Aside Buffer) which include assembly routines and macros.These are
mainly for i386.

/* These routines for flushing tlb uses a register called cr3 
 * But i dont see it(cr3)-is it in tlb- in the list of 386 regs...why?
 */

  // Here 386 memory management techniques are to be understood properly 
  // before moving forward from here.....

               these definitions are self-explaining and mosst important::::

/* PMD_SHIFT determines the size of the area a second-level page table can map
 */
#define PMD_SHIFT       22
#define PMD_SIZE        (1UL << PMD_SHIFT)
#define PMD_MASK        (~(PMD_SIZE-1))

/* PGDIR_SHIFT determines what a third-level page table entry can map */
#define PGDIR_SHIFT     22
#define PGDIR_SIZE      (1UL << PGDIR_SHIFT)
#define PGDIR_MASK      (~(PGDIR_SIZE-1))

/*
 * entries per page directory level: the i386 is two-level, so
 * we don't really have any PMD directory physically.
 */
#define PTRS_PER_PTE    1024
#define PTRS_PER_PMD    1
#define PTRS_PER_PGD    1024
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^These three definitions are responsible for
folding that Linus explained in his comments.

 PAGE_SHIFT in linux/include/asm/page.h defines the size of a page basically.
                       
other macros defined in pgtable.h which use binary calculations are elaborated 
in my "workbook".It is enough to understand most of the paging techniques.
Other set of functions like(pte_none(x),pte_present(x),pte_clear(xp) etc) here
are quie straight forward otherwise.
    other things to remember in a folded two-level set up(as comment says::)
    1. the pgd is never bad  (why???)
    2. pmd always exists  (since it is folded into pgd entry)

Other functions in this file and their use is listed :
  extern inline int pte_read(pte_t pte)   ::  is true if thepage is readable
  extern inline int pte_write(pte_t pte)  ::  if page is writable(_PAGE_RW) 
  extern inline int pte_exec(pte_t pte)   ::  if executable(_PAGE_DIRTY)
  extern inline int pte_young(pte_t pte)  :: if page is young(_PAGE_ACCESSED)
 
 extern inline pte_t pte_wrprotect(pte_t pte) :: write_protects(~_PAGE_RW)
 extern inline pte_t pte_rdprotect(pte_t pte) :: read protects(makes not USER)
 extern inline pte_t pte_exprotect(pte_t pte) :: same as above
 extern inline pte_t pte_mkclean(pte_t pte)  ::makes it not dirty(~_PAGE_DIRY)
 extern inline pte_t pte_mkold(pte_t pte)    ::makes it not old(~_PAGE_ACCESED

 extern inline pte_t pte_mkwrite(pte_t pte) ::make it writeable(|_PAGE_RW)
 extern inline pte_t pte_mkread(pte_t pte)  :: make readable (|_PAGE_USER)
 extern inline pte_t pte_mkexec(pte_t pte)  :: as above-not-kernel
 extern inline pte_t pte_mkdirty(pte_t pte) :: make it dirty(|_PAGE_DIRTY)
 extern inline pte_t pte_mkyoung(pte_t pte) :: make young(_PAGE_ACCESSED)

All the above are very straight forward.......


#################Next are a group of  Conversion functions
 
extern inline pte_t mk_pte(unsigned long page, pgprot_t pgprot)
                page & protection to a page entry
extern inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
extern inline unsigned long pte_page(pte_t pte)
extern inline unsigned long pmd_page(pmd_t pmd)


extern inline pgd_t * pgd_offset(struct mm_struct * mm, unsigned long address)
              +finds an entry in the page-table directory 
              +its one-line statement is
                            return mm->pgd + (address >> PGDIR_SHIFT);
                  ie base of pgd+address shifted by 22 bits right.     
extern inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
              +finds an entry in the second level page table +trivial algo
extern inline pte_t * pte_offset(pmd_t * dir, unsigned long address)
              +find an entry in the third-level page table.. 
                 also straight forward as in pgd_offet

after these are the functions for allocating/deallocating pte,pgd,pmd etc.....
     extern inline pte_t * pte_alloc(pmd_t * pmd, unsigned long address)
              +is simple except for the error handling features(I didnt 
                                              understand them)
     extern inline void pmd_free(pmd_t * pmd)
              +is also trivial...just       pmd_val(*pmd) = 0;
     extern inline pmd_t * pmd_alloc(pgd_t * pgd, unsigned long address)
              +
     extern inline void pgd_free(pgd_t * pgd)
              +
     extern inline pgd_t * pgd_alloc(void)
              +
/* Read all the above lateron
 */

  0.01 ---> uses a (linux/mm/) mem_map array ( i didnt see its definition 
anywhere) to keep record of allocated pages.
  0.01 void free_page(unsigned long addr) just finds the page no of addr(ie
it is divided by PAGE_SIZE or shifted right so many places) and updates mem_map
accordingly(mem_map[page_o] is less than 0 if page number page_no is free).


      Another important place for mm code is /usr/src/linux/arch/i386
arch/i386/fault.c 
     contains function to handle page faults.There is only one function here

asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code)
  comments say as follows about error_code
/* 
 *  error_code:
 *      bit 0 == 0 means no page found, 1 means protection fault
 *      bit 1 == 0 means read, 1 means write
 *      bit 2 == 0 means kernel, 1 means user-mode
 */
               
      
















